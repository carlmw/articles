<!DOCTYPE html><html><head><meta charset="UTF-8"><style>html { font-size: 100%; overflow-y: scroll; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }

body{
  color:#444;
  font-family:Georgia, Palatino, 'Palatino Linotype', Times,
              'Times New Roman', serif,
              "Hiragino Sans GB", "STXihei", "微软雅黑";
  font-size:12px;
  line-height:1.5em;
  background:#fefefe;
  width: 45em;
  margin: 80px auto;
  padding: 5em 5em;
  outline: 1300px solid #FAFAFA;
}

a{ color: #0645ad; text-decoration:none;}
a:visited{ color: #0b0080; }
a:hover{ color: #06e; }
a:active{ color:#faa700; }
a:focus{ outline: thin dotted; }
a:hover, a:active{ outline: 0; }

span.backtick {
  border:1px solid #EAEAEA;
  border-radius:3px;
  background:#F8F8F8;
  padding:0px 3px 0px 3px;
}

::-moz-selection{background:rgba(255,255,0,0.3);color:#000}
::selection{background:rgba(255,255,0,0.3);color:#000}

a::-moz-selection{background:rgba(255,255,0,0.3);color:#0645ad}
a::selection{background:rgba(255,255,0,0.3);color:#0645ad}

p{
margin:1em 0;
}

img{
max-width:100%;
}

h1,h2,h3,h4,h5,h6{
font-weight:normal;
color:#111;
line-height:1em;
}
h4,h5,h6{ font-weight: bold; }
h1{ font-size:2.5em; }
h2{ font-size:2em; }
h3{ font-size:1.5em; }
h4{ font-size:1.2em; }
h5{ font-size:1em; }
h6{ font-size:0.9em; }

blockquote{
color:#666666;
margin:0;
padding-left: 3em;
border-left: 0.5em #EEE solid;
}
hr { display: block; height: 2px; border: 0; border-top: 1px solid #aaa;border-bottom: 1px solid #eee; margin: 1em 0; padding: 0; }


pre , code, kbd, samp { 
  color: #000; 
  font-family: monospace; 
  font-size: 0.88em; 
  border-radius:3px;
  background-color: #F8F8F8;
  border: 1px solid #CCC; 
}
pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; padding: 5px;}
pre code { border: 0px !important; }


b, strong { font-weight: bold; }

dfn { font-style: italic; }

ins { background: #ff9; color: #000; text-decoration: none; }

mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; }

sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }

ul, ol { margin: 1em 0; padding: 0 0 0 2em; }
li p:last-child { margin:0 }
dd { margin: 0 0 0 2em; }

img { border: 0; -ms-interpolation-mode: bicubic; vertical-align: middle; }

table { border-collapse: collapse; border-spacing: 0; }
td { vertical-align: top; }

@media only screen and (min-width: 480px) {
body{font-size:14px;}
}

@media only screen and (min-width: 768px) {
body{font-size:16px;}
}

@media print {
  * { background: transparent !important; color: black !important; filter:none !important; -ms-filter: none !important; }
  body{font-size:12pt; max-width:100%;}
  a, a:visited { text-decoration: underline; }
  hr { height: 1px; border:0; border-bottom:1px solid black; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; padding-right: 1em; page-break-inside: avoid; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}</style></head><body><h1>Making JavaScript testing in the browser not suck with sinon.js (Part 1)</h1>
<p>Writing tests for JavaScript is tough and often overlooked. I'm going to do my best to persuade you why you need them and more importantly how to make it easier to write them with an awesome library called <a href="http://sinonjs.org/">sinon.js</a>.</p>
<h2>When to write them</h2>
<p>Writing JavaScript tests might seem like overkill when you already have a solid functional test suite. Perhaps you're writing nothing but glue code to pull a handful of off the shelf plugins together. In this case you might be able to get away without having JavaScript tests.</p>
<p>Consider the following when deciding whether to write JavaScript tests for a piece of functionality:</p>
<h3>Could this be used on more than one page or multiple times on a single page?</h3>
<p>To properly test your code in a functional suite you'd have to run all your tests on every instance instead of just verifying that it has been initialised where expected. This would slow down your build and introduce duplicate tests.</p>
<h3>Is it non trivial?</h3>
<p>If there's a lot going on within your code then for the sake of peace of mind during refactoring you'll want to be able to rely on your tests to keep you on track.</p>
<p>If you find yourself answering yes to either of the above it's probably a good idea to write some JavaScript tests.</p>
<h2>Getting started</h2>
<p>The are several mature testing frameworks out there and while I have my preferences it's up to you to make up your mind which meets your needs.</p>
<ul>
<li><a href="http://qunitjs.com/">QUnit</a></li>
<li><a href="http://visionmedia.github.com/mocha/">Mocha</a></li>
<li><a href="http://pivotal.github.com/jasmine/">Jasmine</a></li>
</ul>
<h3>Setting up</h3>
<p>First we'll need to create a page to run our tests. We'll include the libraries we plan to use to write our tests.</p>
<p>In my examples I'm going to use QUnit simply because it's the framework I'm most familiar with and the tests are the easiest to read. Check out <a href="http://docs.jquery.com/QUnit#Using_QUnit">using QUnit</a> for detailed setup instructions. You'll also need sinon, so head over to <a href="http://sinonjs.com">sinonjs.com</a> and download it along with the QUnit adapter.</p>
<p>Here's my test runner, I've chucked in jQuery too because it's a defacto standard and makes it much easier to test the DOM.</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;Test Suite&lt;/title&gt;
    &lt;link rel="stylesheet" href="qunit.css" /&gt;
    &lt;script src="jquery.min.js"&gt;&lt;/script&gt;
    &lt;script src="qunit.js"&gt;&lt;/script&gt;
    &lt;script src="sinon-1.3.4.js"&gt;&lt;/script&gt;
    &lt;script src="sinon-qunit.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="qunit"&gt;&lt;/div&gt;
    &lt;div id="qunit-fixture"&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>If we run that in a browser we should see this:</p>
<p><img alt="No tests" src="no_tests.png" /></p>
<h3>Writing a simple test</h3>
<p>Lets start with something very basic. We're going to write something that will let us build up a list of values and render them to a page. We could start with a test like this:</p>
<pre><code>module('listView');

test('The user is presented with a list of added items', function () {
  document.getElementById('qunit-fixture').innerHTML = '&lt;div id="list"&gt;&lt;/div&gt;';
  var domList = document.getElementById('list'),
      list = listView(domList);

  list.addOne('javascript');
  list.render();

  equal(domList.innerHTML, 'javascript', 'A single value should be rendered');

  list.addOne('ftw');
  list.render();

  equal(domList.innerHTML, 'javascript ftw', 'A list of values should be rendered');
});
</code></pre>
<p>Here we're creating a fixture element and instantiating our new module. We're then exercising a public method called addOne with a string and asserting that each time we call render the expected string is inserted into our element. Lets run our test and see it fail:</p>
<p><img alt="Failing test" src="fail.png" /></p>
<p>Now lets write some code to get this test to pass:</p>
<pre><code>var listView = function (domEl) {
  var items = [];
  return {
    addOne: function (value) {
      items.push(value);
    },
    render: function () {
      domEl.innerHTML = items.join(' ');
    }
  };
};
</code></pre>
<p><img alt="Passing test" src="pass.png" /></p>
<p>There we go, our first test passes. Now onto more complicated matters.</p>
<h3>Getting asyncronous</h3>
<p>Now lets alter our listView module to load some data from the server. This presents us with two problems:</p>
<ol>
<li>We don't want to request data from a real server. This would be slow and means we can't test our code in isolation.</li>
<li>The request could return at any time and our test doesn't know when to expect it.</li>
</ol>
<h3>Sinon.js to the rescue</h3>
<p>Sinon is a collection of utterly essential testing tools that among other things enable you to deal with tricky asyncronous code and server requests.</p>
<p>Lets write a new test:</p>
<pre><code>var xhr,
    requests,
    domList;

module('listView', {
  setup: function () {
    xhr = sinon.useFakeXMLHttpRequest()
    requests = [];
    xhr.onCreate = function (r) {
      requests.push(r);
    };
    document.getElementById('qunit-fixture').innerHTML = '&lt;div id="list"&gt;&lt;/div&gt;';
    domList = document.getElementById('list');
  },
  teardown: function () {
    xhr.restore();
  }
});

test('The list is populated from the server', function () {
  var list = listView(domList);
  list.fetch();

  equal(requests.length, 1, 'One XHR request should be made');

  requests[0].respond(200, {'Content-Type': 'application/json'}, '["XHR", "INNIT"]');

  equal(requests[0].url, '/path/to/list.json', 'A request to the correct URL should be made');

  list.render();

  equal(domList.innerHTML, 'XHR INNIT', 'The retrieved values should be rendered');
});
</code></pre>
<p>We've now defined a setup function for our test suite which setups a fake XMLHttpRequest object that will intercept any attempt to communicate over XHR and allow us to define our own responses. Even better it will make our request syncronous since we're responding to our fake request immediately from inside our test; pretty cool. </p>
<p>Lets update listView and get that test to pass:</p>
<pre><code>var listView = function (domEl) {
  var items = [];
  return {
    addOne: function (value) {
      items.push(value);
    },
    render: function () {
      domEl.innerHTML = items.join(' ');
    },
    fetch: function () {
      $.getJSON('/path/to/list.json', function (response) {
        items = response;
      });
    }
  };
};
</code></pre>
<p>Run the tests</p>
<p><img alt="All tests passing" src="all_passed.png" /></p>
<p>Perfect.</p>
<h2>Burning through time</h2>
<p>When testing JavaScript animation or other asyncronous functionality based on timeouts and intervals you don't want to have to wait for them to finish in your tests.</p>
<p>Sinon.js solves this for you with fake timers. Sinon will replace the browsers timing functions with it's own. This enables you to advance the clock manually and test what your code does in response.</p>
<p>Lets write a test to animate a simple cube:</p>
<pre><code>test('cube is animated for 1 second', function () {
  document.getElementById('qunit-fixture').innerHTML = '&lt;div id="cube"&gt;&lt;/div&gt;';

  var domCube = document.getElementById('cube'),
      cube = animatedCube(domCube),
      clock = sinon.useFakeTimers();

  cube.animate();

  clock.tick(100);

  equal(domCube.style.left, '10px', 'Cube has moved 10px left after 100ms');

  clock.tick(100);

  equal(domCube.style.left, '20px', 'Cube has moved 20px left after 200ms');

  clock.tick(800);

  equal(domCube.style.left, '100px', 'Cube has moved 100px left after 1000ms');

  clock.tick(100);

  equal(domCube.style.left, '100px', 'Cube has stopped moving');

  clock.restore();
});
</code></pre>
<p>In this test we're telling sinon to replace the browsers timers and then incrementally advancing the timer to interesting points in our animation and asserting that the cube is where we expect it to be.</p>
<p>And now lets make the test pass:</p>
<pre><code>var animatedCube = function (domEl) {
  var x = 0,
      start,
      diff,
      interval,
      loop = function () {
        diff = Date.now() - start;
        x = Math.round((100 / 1000) * diff);
        domEl.style.left = x + 'px';
        if (x &gt;= 100) clearInterval(interval);
      };

  domEl.style = 'width:10px;height:10px;background-color:red;position:relative';

  return {
    animate: function () {
      start = Date.now();
      interval = setInterval(loop, 10);
    }
  };
};
</code></pre>
<p>Hopefully this has served as a useful introduction to effective JavaScript testing in the browser.</p>
<p>In the second part of this article i'll write about sinon spies, mocks and stubs.</p></body>